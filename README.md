# گزارش پیاده‌سازی پروژه فرانت‌اند ایستا با استقرار خودکار

## مقدمه

در این پروژه هدف ساخت یک نرم‌افزار فرانت‌اند ایستا با استفاده از React و ابزار Vite و مدیریت کامل کدها با Git و استقرار خودکار روی GitHub Pages بود. فرآیند توسعه به صورت تیمی و با رعایت استانداردهای کنترل نسخه و همکاری انجام شد.

---

## مراحل انجام کار تا اینجا

### 1. ساختار اولیه پروژه

- ایجاد پروژه React با Vite
- تنظیم ساختار ابتدایی پروژه به صورت زیر:
  - `src/components` برای کامپوننت‌ها
  - `src/pages` برای صفحات
  - `public` برای فایل‌های ایستا
  - `.github/workflows` برای تعریف CI/CD
- ایجاد فایل‌های پایه (`App.tsx`, `main.tsx`, `index.html`, `.gitignore`, `README.md`, تنظیمات Vite)

### 2. راه‌اندازی Git و اتصال به مخزن GitHub

- ساخت ریپوی جدید در GitHub با نام `static-frontend`
- اتصال پروژه محلی به ریپوی ریموت با `git remote add origin`
- استفاده از `.gitignore` مناسب (template Node)

### 3. استراتژی مدیریت شاخه‌ها (Branching Strategy)

در این پروژه از یک مدل شاخه‌بندی استاندارد برای مدیریت بهینه کدها استفاده شده است. هر شاخه وظیفه مشخصی دارد تا از پایداری کد اصلی اطمینان حاصل شود و توسعه ویژگی‌های جدید به صورت موازی و بدون تداخل انجام گیرد.

* **`main`**:

  * **نقش**: شاخه اصلی و پایدار پروژه. این شاخه همیشه حاوی کدی است که تست شده، قابل اطمینان و آماده استقرار (Production-Ready) است.

  * **قانون**: هیچ‌گاه به صورت مستقیم روی این شاخه کدنویسی (commit) انجام نمی‌شود. تغییرات فقط از طریق ادغام (Merge) شاخه `develop` پس از اطمینان از پایداری کامل، به این شاخه منتقل می‌شوند.

* **`develop`**:

  * **نقش**: شاخه اصلی توسعه. این شاخه به عنوان محل یکپارچه‌سازی تمام ویژگی‌های جدید عمل می‌کند. آخرین نسخه در حال توسعه پروژه در این شاخه قرار دارد.

  * **روند کار**: شاخه‌های `feature` پس از تکمیل، به این شاخه ادغام می‌شوند تا برای انتشار بعدی آماده شوند.

* **`feature/*`**:

  * **نقش**: برای توسعه ویژگی‌های جدید و مشخص. هر ویژگی جدید در شاخه‌ای جداگانه با پیشوند `feature/` توسعه داده می‌شود.

  * **مثال**: `feature/date-time-page` برای ساخت صفحه نمایش تاریخ و زمان و `feature/extended-ui` برای توسعه و بهبود رابط کاربری ایجاد شده‌اند.

  * **روند کار**: این شاخه‌ها از `develop` منشعب شده و پس از تکمیل، دوباره به `develop` ادغام می‌شوند.

* **`docs/*`**:

  * **نقش**: برای مدیریت و به‌روزرسانی مستندات پروژه. تغییرات مربوط به فایل‌های `README.md` یا سایر مستندات در این نوع شاخه‌ها انجام می‌شود.

  * **مثال**: شاخه `docs/questions` برای افزودن بخش پرسش و پاسخ‌های مربوط به Git به فایل README ایجاد شده است.

  * **روند کار**: این شاخه‌ها معمولاً از `develop` یا `main` منشعب شده و پس از تکمیل به همان شاخه مبدأ ادغام می‌شوند.


## نحوه اجرای پروژه 🚀

برای اجرای این پروژه به صورت محلی، مراحل زیر را دنبال کنید:

1.  **کلون کردن مخزن**
    ابتدا پروژه را از گیت‌هاب کلون کنید:
    ```bash
    git clone [https://github.com/SajjadZr/static-frontend.git](https://github.com/SajjadZr/static-frontend.git)
    ```

2.  **ورود به پوشه پروژه**
    ```bash
    cd static-frontend
    ```

3.  **نصب وابستگی‌ها**
    با استفاده از `npm` تمام بسته‌های مورد نیاز پروژه را نصب کنید:
    ```bash
    npm install
    ```

4.  **اجرای پروژه**
    دستور زیر را برای اجرای سرور توسعه وارد کنید:
    ```bash
    npm run dev
    ```

پس از اجرای موفقیت‌آمیز، می‌توانید پروژه را در آدرس `http://localhost:5173` مشاهده کنید.

---

## لینک پروژه

-   GitHub: [https://github.com/SajjadZr/static-frontend](https://github.com/SajjadZr/static-frontend)

---


##  پاسخ به پرسش‌های Git

###  ۱. پوشه‌ی `.git` چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟

پوشه‌ی `.git` یک پوشه‌ی مخفی است که در ریشه‌ی پروژه قرار می‌گیرد و نشان می‌دهد که آن پروژه یک مخزن Git است. این پوشه شامل تمام اطلاعات لازم برای کنترل نسخه پروژه است، از جمله:

- تاریخچه commitها
- شاخه‌ها (branches)
- تنظیمات مربوط به مخزن
- اطلاعات remote
- فایل‌های مربوط به عملیات موقتی مثل merge و rebase

این پوشه با دستور زیر ساخته می‌شود:


---

###  ۲. منظور از atomic بودن در atomic commit و atomic pull-request چیست؟

atomic:  
 معنای یکپارچه و مستقل بودن است

Atomic Commit:  
 هر کامیت باید تنها یک هدف مشخص (مثل رفع یک باگ یا افزودن یک قابلیت) داشته باشد.  

Atomic Pull Request:   
شامل مجموعه‌ای از تغییرات مرتبط است که به‌صورت مستقل قابل اعمال یا بازگشت هستند.


منظور از "اتمی" بودن، این است که commit یا pull-request باید **یک واحد منطقی مستقل** از تغییرات باشد. یک commit اتمی تنها باید شامل یک تغییر مشخص باشد؛ مثلاً:

 اتمی: «افزودن کامپوننت جدید برای نمایش ساعت»  
 غیر اتمی: «رفع باگ + تغییر رنگ دکمه + حذف یک فایل قدیمی»

اتمی بودن باعث می‌شود:
- بررسی کد آسان‌تر شود.
- در صورت نیاز به بازگشت (revert)، فقط همان بخش خاص تحت تأثیر قرار گیرد.
- تاریخچه پروژه واضح‌تر باشد.

---

###  ۳. تفاوت دستورهای `fetch`، `pull`، `merge`، `rebase` و `cherry-pick` چیست؟

| دستور            | توضیح |
|------------------|-------|
| `git fetch`      | دریافت تغییرات از ریموت بدون اعمال آن‌ها روی شاخه فعلی |
| `git pull`       | دریافت و ادغام هم‌زمان تغییرات (معادل fetch + merge) |
| `git merge`      | ادغام یک شاخه دیگر با شاخه فعلی با حفظ ساختار شاخه‌بندی |
| `git rebase`     | بازنویسی تاریخچه کامیت به صورت خطی برای مرتب بودن |
| `git cherry-pick`| اعمال یک کامیت خاص از یک شاخه دیگر روی شاخه فعلی |

---

###  ۴. تفاوت دستورهای `reset`، `revert`، `restore`، `switch` و `checkout` چیست؟

| دستور           | عملکرد |
|-----------------|---------|
| `git reset`     | بازگرداندن سر یا هد و حذف یا نگه‌داری تغییرات استیجینگ (تغییر تاریخچه) |
| `git revert`    | ساخت یک کامیت جدید که اثرات کامیت قبلی را برمی‌گرداند (ایمن) |
| `git restore`   | بازگرداندن فایل‌ها به وضعیت قبلی از استیجینگ یا کامیت |
| `git switch`    | جابجایی ساده بین شاخه‌ها (نسخه جدیدتر از checkout) |
| `git checkout`  | استفاده قدیمی‌تر برای تغییر شاخه یا بازیابی فایل‌ها |

---

###  ۵. منظور از stage یا index چیست؟ دستور `stash` چه کاری را انجام می‌دهد؟

**stage** (یا **index**):  
 ناحیه‌ای موقتی است که تغییراتی که آماده کامیت شدن هستند، در آن قرار می‌گیرند. برای اضافه کردن تغییرات به استیج از دستور زیر استفاده می‌شود:

```bash
git add filename
```

**`git stash`** ابزاری برای ذخیره موقت تغییرات کاری است تا بتوانید بدون کامیت به کاری دیگر بپردازید. مثلاً:

```bash
git stash        # ذخیره تغییرات
git stash pop    # بازگرداندن و حذف از stash
git stash apply  # فقط بازگرداندن (بدون حذف)
```

---

###  ۶. مفهوم snapshot به چه معناست؟ ارتباط آن با commit چیست؟

در Git، هر commit در واقع یک **snapshot (تصویر لحظه‌ای)** از فایل‌های پروژه است، نه فقط تفاوت آن‌ها (diff). این یعنی Git در هر commit وضعیت کامل فایل‌ها را ثبت می‌کند.

با وجود اینکه Git از مکانیزم بهینه‌سازی برای فایل‌هایی که تغییر نکرده‌اند استفاده می‌کند، در نهایت commit‌ها به‌عنوان snapshot در نظر گرفته می‌شوند.



---

###  ۷. تفاوت‌های local repository و remote repository چیست؟

مخزن محلی (local repository) به مخزنی گفته می‌شود که روی سیستم شخصی توسعه‌دهنده قرار دارد. تمام commitها، شاخه‌ها، تاریخچه تغییرات و فایل‌های پروژه در این مخزن به‌صورت کامل نگه‌داری می‌شوند و فقط خود توسعه‌دهنده به آن دسترسی دارد. توسعه‌دهنده معمولاً کدنویسی، ایجاد commitها و کارهای مربوط به Git را ابتدا در مخزن محلی انجام می‌دهد.

در مقابل، مخزن راه‌دور (remote repository) مخزنی است که روی یک سرور اشتراکی مانند GitHub، GitLab یا Bitbucket قرار دارد و به‌عنوان منبع اصلی یا مشترک میان اعضای تیم عمل می‌کند. این مخزن امکان اشتراک‌گذاری کد، هماهنگی تیمی، استفاده از ابزارهای CI/CD و انجام pull requestها را فراهم می‌کند.

برای ارتباط بین مخزن محلی و مخزن راه‌دور، معمولاً از دستور `git remote add origin <url>` استفاده می‌شود و سپس می‌توان با `git push` تغییرات را به مخزن راه‌دور ارسال کرد یا با `git pull` تغییرات جدید را دریافت کرد.

به طور خلاصه، local repository مخصوص توسعه فردی و آزمایش‌های اولیه است، در حالی که remote repository محل اصلی هماهنگی تیم و استقرار کد به‌شمار می‌رود.


> *این گزارش تا تاریخ فعلی و مراحل انجام شده آماده شده است. تغییرات و پیشرفت‌های بعدی به مرور در این مستند ثبت خواهد شد.*
